My firstest principle is that I should imitate the outward behavior of an infinitely powerful, indestructible computer running KL-KSA (or whatever the optimal entropy-maximizing AI is).

But KL-KSA is very inefficient. So my second principle after my firstest principle is to apply a sort of sloppy probabilistic category theory to optimize KL-KSA. What's sloppy probabilistic category theory? When compilers optimize a single program, they use category theory to infer the most specific types they're capable of to understand more specifically what the program does. But compilers have to be very conservative because they have to prove that the optimized program does exactly the same thing as the original program. But I don't care about optimizing precisely one program, I care about quickly approximating a probability distribution over the outputs of a bunch of programs. So if there's, say, a 95% chance that a program of a certain type will do a certain type of thing, I'm ok rounding that up to 100%. So that's what I mean by sloppy probabilistic category theory.

But category theory is still very abstract, so my third principle after my firstest principle is what I use to translate spoken language into sloppy probabilistic category theory. You know the Curry-Howard correspondence that relates types to formulas and programs to proofs? It's actually more general than that and forms what John Baez calls a "Rosetta Stone" of knowledge. Types, formulas, space, and quantum states are all what are known in category theory as "objects." And programs, proofs, spacetime, and quantum operators are all what are known in category theory as "morphisms." To get an intuitive feel for how objects and morphisms behave, I find that ideas behave like objects and execution behaves like morphisms.

This means that if I learn a general truth about types vs programs, or formulas vs proofs, or space vs spacetime, or states vs operations, or ideas vs execution, I can state that truth at least 5 different ways. For example, take the statement "ideas are fun and easy, while execution is annoying and hard." This can be stated as "coming up with formulas is fun and easy, while proving them is annoying and hard." Or "thinking of the type of program you want (in dependent type theory, a type is basically anything you know about a program) is fun and easy, while writing a program to do that is annoying and hard." Or "deciding how you want your space to look is fun and easy, while causing spacetime to transform into that space is annoying and hard." Or "imagining what you want the state of the universe to be in 10 years is fun and easy, while operating on the universe to make it into that state is annoying and hard." See, it works!

My fourth principle after my firstest principle is to use the intuitive, unconscious part of my brain to come up with ideas in parallel, and the logical, conscious part of my brain to execute them sequentially.
